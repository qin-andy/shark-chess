# -*- coding: utf-8 -*-
"""Shark Chess.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10k5gCzjk2CR84qOzExWf66O-xwOva5Ig

# Computer Chess Tourney

## Imports and Packages
"""

import random
import time
import typing
import math

import matplotlib.pyplot as plt

import numpy as np
import pandas as pd

import chess
import chess.svg
import chess.engine
import chess.pgn


"""## Testing Chess Package

Stockfish vs Random Moves
"""

stockfish_path = '.\stockfish\stockfish_15.1_win_x64_popcnt\stockfish_15.1_win_x64_popcnt\stockfish-windows-2022-x86-64-modern.exe'

"""## Interchangeable Bot Setup
Bot game player engine, pits two ChessBots against eachogther by repeatedly having them generate moves

"""


# Base chess bot
class ChessBot:
  def __init__(self):
    # for storing "move reasoning" for inspection
    self.logs = []
    self.reasoning = ""

  def make_move(self, board: chess.Board) -> typing.Tuple[chess.Move, str]:
    pass

  def get_reasoning(self):
    return self.reasoning

  def __str__(self):
    return "Base"


# Result to store results from a game plaed
class GameResult:
  def __init__(self):
    self.white_player = None
    self.black_player = None
    self.winner = None
    self.moves = None
    self.time = None
    self.pgn = None
    self.end_reason = None
    self.pc_game = None
    self.pc_board = None

  def __str__(self):
    result = ""
    result += "[" + self.white_player + "]" + " vs " + "[" + self.black_player + "]"
    return result


def create_game_result(wb: ChessBot, bb: ChessBot,
                       board: chess.Board, game: chess.pgn.Game):
  # Basic Naming
  gr = GameResult()
  gr.white_player = str(wb)
  gr.black_player = str(bb)
  gr.moves = board.fullmove_number

  game.headers['Event'] = "Bot Match"
  game.headers['White'] = str(wb)
  game.headers['Black'] = str(bb)

  gr.pgn = str(game)

  # For testing, remove later-
  gr.pc_board = board
  gr.pc_game = game

  # Outcome
  outcome = board.outcome()
  # No board outcome means turn limit was hit
  if outcome == None:
    gr.winner = 'Draw'
    gr.end_reason = 'Turn Limit'
  else:
    gr.end_reason = outcome.termination.name
    if outcome.winner == None:
      # No winner means stalement
      gr.winner = 'Stalemate'
    else:
      # Winner is either black or white bot
      if outcome.winner:
        gr.winner = str(wb)
      else:
        gr.winner = str(bb)
  return gr


# Helper that creates a random legal move
def move_rand(board: chess.Board) -> chess.Move:
  moves = board.generate_legal_moves()
  moves_arr = [move for move in moves]
  rand_move = random.choice(moves_arr)
  return rand_move


# Always random move bot
class AlwaysRandomBot(ChessBot):
  def make_move(self, board):
    return move_rand(board), 'random'

  def __str__(self):
    return "AlwaysRandom"


# Full Stockfish Bot
# Limit - thinking time in seconds
class Stockfish100Bot(ChessBot):
  def __init__(self, engine: chess.engine.SimpleEngine, limit):
    super().__init__()
    self.engine = engine
    self.limit = limit

  def make_move(self, board):
    comment = 'Stockfish' + str(self.limit.time)
    result = self.engine.play(board, self.limit)
    return result.move, comment

  def __str__(self):
    return "SF:" + str(self.limit)


# Water Bot
# Waters down any two bots by giving a random ratio of moves from one to the other
class WaterBot(ChessBot):
  def __init__(self, b1: ChessBot, b2: ChessBot, water_ratio: float):
    super().__init__()
    self.b1 = b1
    self.b2 = b2
    self.water_ratio = water_ratio
    self.custom_name = None

  def make_move(self, board):
    move = chess.Move
    if random.random() <= self.water_ratio:
      move, comment = self.b1.make_move(board)
      return move, 'W[o]-' + comment
    else:
      move, comment = self.b2.make_move(board)
      return move, 'W[x]-' + comment

  def __str__(self):
    if self.custom_name == None:
      return 'W:[' + str(self.b1) + str(self.b2) + ']R:' + str(self.water_ratio)
    return self.custom_name


# Always does moves which check. Then captures, then random after.
class BerserkBot(ChessBot):
  def make_move(self, board):
    checks_arr = [move for move in board.generate_legal_moves() if board.gives_check(move)]
    captures_arr = [move for move in board.generate_legal_moves() if board.is_capture(move)]
    moves_arr = [move for move in board.generate_legal_moves()]
    if checks_arr:
      return random.choice(checks_arr), 'Check Spotted'
    elif captures_arr:
      return random.choice(captures_arr), 'Capture Spotted'
    else:
      return random.choice(moves_arr), 'Nothing Spotted'

  def __str__(self):
    return "Berserk"


# Prioitizes none-capturing moves.
class PacifistBot(ChessBot):
  def make_move(self, board):
    checks_arr = [move for move in board.generate_legal_moves() if board.gives_check(move)]
    captures_arr = [move for move in board.generate_legal_moves() if board.is_capture(move)]
    moves_arr = [move for move in board.generate_legal_moves()]
    safe_moves_arr = [move for move in moves_arr if
                      (not board.gives_check(move)) and (not board.is_capture(move))]
    if safe_moves_arr:
      return random.choice(safe_moves_arr), 'Safe move spotted'
    else:
      return random.choice(moves_arr), 'I must resort to violence'

  def __str__(self):
    return "Pacifist"


# Prioitizes moving king (randomly)
class DanceKingBot(ChessBot):
  def make_move(self, board):
    moves_arr = [move for move in board.generate_legal_moves()]
    king_moves = [move for move in moves_arr if move.from_square == board.king(board.turn)]
    if king_moves:
      return random.choice(king_moves), 'King going in!'
    else:
      return random.choice(moves_arr), 'Im trapped!'

  def __str__(self):
    return "DanceKing"


# Prioitizes moving king towards enemy king
class SuicideKingBot(ChessBot):
  def make_move(self, board):
    moves_arr = [move for move in board.generate_legal_moves()]
    king_moves = [move for move in moves_arr if move.from_square == board.king(board.turn)]

    target_square = board.king(not board.turn)  # Find opponent turn

    king_moves.sort(key=lambda x: chess.square_distance(x.to_square, target_square))
    if king_moves:
      curr_dist = chess.square_distance(board.king(board.turn), target_square)
      # If the closest king move would move it farther from the enemy king, pass
      if chess.square_distance(king_moves[0].to_square, target_square) >= curr_dist:
        return random.choice(moves_arr), 'King is close enough!'
      return king_moves[0], 'King closing distance!'
    else:
      return random.choice(moves_arr), 'No king moves!!'

  def __str__(self):
    return "SuicideKing"


# Plays with Stockfish strength except when in check, then moves randomly
class PanicFishBot(ChessBot):
  def __init__(self, engine: chess.engine.SimpleEngine, limit):
    super().__init__()
    self.engine = engine
    self.limit = limit

  def make_move(self, board):
    if board.is_check():
      return move_rand(board), "Panic!!!"
    else:
      comment = 'Calm' + str(self.limit.time)
      result = self.engine.play(board, self.limit)
      return result.move, comment

  def __str__(self):
    return "PanicFish"


# After capturing, gets excited and begins lurking, before entering a frenzy
class SharkFishBot(ChessBot):
  def __init__(self, shallow_bot: ChessBot, lurk_time, frenzy_time,
               engine: chess.engine.SimpleEngine, limit):
    super().__init__()
    self.custom_name = None
    self.shallow_bot = shallow_bot
    self.lurk_time = lurk_time
    self.frenzy_time = frenzy_time
    self.excitement_time = 0
    self.engine = engine
    self.limit = limit

  def make_move(self, board):
    # Excitement Case
    if self.excitement_time > 0:
      if self.excitement_time <= self.frenzy_time:
        comment = 'Frenzy! for [' + str(self.excitement_time) + '] turns'
        result = self.engine.play(board, self.limit)
        self.excitement_time -= 1
        return result.move, comment
      else:
        move, comment = self.shallow_bot.make_move(board)
        lurk_comment = '...lurking... for [' + str(self.excitement_time) + '] turns'
        comment = lurk_comment + ' --- ' + comment
        self.excitement_time -= 1
        return move, comment
    # Make a shallow move. If it's a check or capture, get excited
    move, comment = self.shallow_bot.make_move(board)
    if board.gives_check(move) or board.is_capture(move):
      self.excitement_time = self.lurk_time + self.frenzy_time
      comment = '...smelling blood... --- ' + comment
    return move, comment

  def __str__(self):
    if self.custom_name == None:
      return 'Shark[' + str(self.shallow_bot) + ']R:' + str(self.limit)
    return self.custom_name


# Play a single game between bots
def play_game(wb: ChessBot, bb: ChessBot, turn_limit: int):
  board = chess.Board()
  game = chess.pgn.Game()
  node = game
  turns = 0

  start_time = time.time()
  while not board.is_game_over() and turns <= turn_limit:
    move = None
    if board.turn:
      move, comment = wb.make_move(board)
    else:
      move, comment = bb.make_move(board)
    node = node.add_variation(move)
    node.comment = comment
    board.push(move)
    turns += 1
  game.end()
  game_result = create_game_result(wb, bb, board, game)
  game_result.time = time.time() - start_time
  return game_result


"""## Concrete Bot Setup"""

engine = chess.engine.SimpleEngine.popen_uci(stockfish_path)

base_limit = chess.engine.Limit(time=0.1, depth=10)

bot_ar = AlwaysRandomBot()
bot_sf = Stockfish100Bot(engine, base_limit)
bot_berserk = BerserkBot()
bot_panic = PanicFishBot(engine, base_limit)
bot_pacifist = PacifistBot()
bot_dance_king = DanceKingBot()
bot_suicide_king = SuicideKingBot()

# Water Bot levels
water_fish_80 = WaterBot(bot_sf, bot_ar, 0.8)
water_fish_80.custom_name = "WaterFish80"

water_fish_30 = WaterBot(bot_sf, bot_ar, 0.3)
water_fish_30.custom_name = "WaterFish30"

# Sharkfish
shark_fish = SharkFishBot(bot_ar, 0, 5, engine, base_limit)

# Test a game
game_result = play_game(bot_pacifist, bot_suicide_king, 500)
print(game_result.pc_board.outcome())

board_svg = chess.svg.board(game_result.pc_board)
# display(game_result.pc_board)
print(game_result.pc_game)

"""## Water Bot Generation

"""

# creates list of bots
bots = []


def generate_water_bots(b1, b2, name=None):
  mixes = [0.1, 0.2, 0.8, 0.9]
  water_bots = []
  for mix in mixes:
    water_bot = WaterBot(b1, b2, mix)
    if not name == None:
      water_bot.custom_name = name + str(int(mix * 100))
    water_bots.append(water_bot)
  return water_bots


# bots += generate_water_bots(bot_sf, bot_ar, "Waterfish")
# bots += generate_water_bots(bot_sf, bot_berserk, "Torrent")

for bot in bots:
  print(bot)

"""# Match Running

## Elo Calcuations
"""


def win_prob(rating1, rating2):
  return 1.0 * 1.0 / (1 + 1.0 * math.pow(10, 1.0 * (rating2 - rating1) / 400))
  # Geeks for geeks was wrong..... their version has a typo int he above alg


# Takes 1 ELO,s a K value, and d = winner == 1
def calculate_elos(rating1, rating2, K, d):
  prob1 = win_prob(rating1, rating2)
  prob2 = win_prob(rating2, rating1)
  # print(prob1, prob2)
  # Case -1 When Player A wins
  if (d == 1):
    rating1 += K * (1 - prob1)
    rating2 += K * (0 - prob2)

  # Case -2 When Player B wins
  elif (d == 0):
    rating1 += K * (0 - prob1)
    rating2 += K * (1 - prob2)

  # Tie case
  else:
    rating1 += K * (0.5 - prob1)
    rating2 += K * (0.5 - prob2)

  return int(rating1), int(rating2)


print(calculate_elos(1200, 1000, 32, 0.5))
# Populate names and ELOs
elo_k = 32  # Determines how much Elo goes up and down

"""## Multigame Match Setup"""


# Actually play the games

# Helper to play multiple games between two bots
def multiplay(wb, bb, count, elos=None):
  grs = []  # game results array
  for i in range(count):
    print('Game [' + str(i + 1) + '/' + str(count) + "] of [" + str(wb) + "] vs [" + str(bb) + "]")
    gr = play_game(wb, bb, 300)
    print(gr.winner + ' wins in [' + str(gr.moves) + '] turns in [' + str(gr.time) + '] seconds')
    if elos:  # Update Elos case
      if str(wb) == str(bb):
        pass
      else:
        winner = 0.5
        if (gr.winner == str(wb)):
          winner = 1
        elif (gr.winner == str(bb)):
          winner = 0
        elos[str(wb)], elos[str(bb)] = calculate_elos(elos[str(wb)], elos[str(bb)], elo_k, winner)
        print(str(wb) + ': ' + str(elos[str(wb)]) + ', ' + str(bb) + ': ' + str(elos[str(bb)]))
    grs.append(gr)
  return grs


"""## Run Single Bot Match"""


def play_match(b1, b2, games_count, swap_colors=True, elos=None):
  print('=========<' + str(b1) + ' [vs] ' + str(b2) + '>=========')
  # Time and play games
  start_time = time.time()
  grs = []

  grs += multiplay(b1, b2, games_count, elos)
  if swap_colors:
    grs += multiplay(b2, b1, games_count, elos)  # switch colors
  end_time = time.time()
  print('Total Time: ' + str((end_time - start_time)))
  print()

  return grs


"""## Run Bot Tournament


"""

# Initializing bots
base_limit = chess.engine.Limit(time=0.1, depth=10)

shark_angry = SharkFishBot(bot_berserk, 0, 3, engine, base_limit)
shark_angry.custom_name = "BerserkShark"

shark_lurk = SharkFishBot(bot_berserk, 2, 7, engine, base_limit)
shark_lurk.custom_name = "LurkShark"

torrent_80 = WaterBot(bot_sf, bot_berserk, 0.8)
torrent_80.custom_name = 'Torrent80'

# bots_x = [bot_dance_king, bot_suicide_king, bot_ar, bot_pacifist, bot_berserk,
#           shark_angry, shark_lurk,
#           torrent_80, water_fish_80, bot_sf,
#           bot_panic]

bots_x = [bot_dance_king, bot_suicide_king]
# Setting up required resources
player_names = []
elos = {}
for bot in bots_x:
  player_names.append(str(bot))
  elos[str(bot)] = 800
print(player_names)


def play_tournament(bots, match_length, swap_colors):
  start_time = time.time()
  match_total = len(bots) ** 2
  match_count = 0
  grs = []
  for b1 in bots:
    for b2 in bots:
      match_count += 1
      # Play a single one-sided match (no color swapping)
      print('Match ' + str(match_count) + '/' + str(match_total))
      grs += play_match(b1, b2, match_length, swap_colors, elos)
  total_time = time.time() - start_time
  print('Total time for tournament: ' + str(total_time))
  return grs


engine.close()

### PLAY THE TOURNAMENT!
game_results = play_tournament(bots_x, 1, False)

# Bot Names for Labelling

"""# Tournament Analysis

## Multigame Match Analysis
"""

# Data into Pandas

winners = []
reasons = []
moves = []
times = []
pgns = []
whites = []
blacks = []

# Unzip array of game objects into arrays
for gr in game_results:
  winners.append(gr.winner)
  reasons.append(gr.end_reason)
  moves.append(gr.moves)
  times.append(gr.time)
  pgns.append(gr.pgn)
  whites.append(gr.white_player)
  blacks.append(gr.black_player)

# Settingup data in dict
game_data = {
  'Winner': winners,
  'End Reason': reasons,
  'Moves': moves,
  'Time': times,
  'PGN': pgns,
  'White': whites,
  'Black': blacks
}

# Into Pandas :3
df = pd.DataFrame(game_data)
df.to_csv('output.csv', encoding='utf-8-sig')
# files.download('output.csv')

# Summary Analysis of DF
df.groupby("Winner").count()
# Win percents
df['Winner'].value_counts(normalize=True)

"""## Elo Chart"""

print(elos)
kvs = list(elos.items())
kvs.sort(key=lambda x: x[1])
print(kvs)
names_by_elo, elo_values = zip(*kvs)

plt.bar(range(len(elos)), elo_values, tick_label=names_by_elo)
plt.xticks(rotation=90)
# plt.show()
plt.savefig('elos.png')  # TODO : fix sizing

"""## Matchup Chart Creation"""

matchups_dict = {}
round_to_decimals = 3

# overwrite playernames to be sorted by elo
player_names = names_by_elo

for white_player in player_names:
  matchups_dict[white_player] = {}
  for black_player in player_names:
    # Collect all matches from database with white player and black player
    # Consolidate them into stalement and win/loss/staledraw (store as tuple first?)
    # In future, cinlude more info, like average move length
    white_wins = 0.0
    white_drawmates = 0.0
    white_losses = 0.0
    for index, item in df.loc[(df['White'] == white_player) & (df['Black'] == black_player)]['Winner'].value_counts(
            normalize=True).items():
      # Value will be one of white_player, black_player, draw, or Stalement (Stalemate)
      if index == white_player:
        white_wins = round(item, round_to_decimals)
      elif (index == 'Stalemate') or (index == 'Draw'):
        white_drawmates += round(item, round_to_decimals)
    white_losses = round(1 - (white_wins + white_drawmates), round_to_decimals)

    # Append to dict
    matchups_dict[white_player][black_player] = (white_wins, white_drawmates, white_losses)
    # matchups_dict[white_player][black_player] = white_wins
matchups_df = pd.DataFrame(matchups_dict)

ticks = player_names

matchups_rgb = np.array(matchups_df.values.tolist()).astype('float')


def scale_rgb(i):
  new = (i * 0.5) + 0.25
  return i


applyall = np.vectorize(scale_rgb)
matchups_rgb = applyall(matchups_rgb)

plt.figure(figsize=(7, 7))
plt.xlabel("White Player")
plt.ylabel("Black Player")
plt.xticks(range(len(player_names)), player_names, rotation=90)
plt.yticks(range(len(player_names)), player_names)
plt.imshow(matchups_rgb)
# plt.show()
plt.savefig('matchups.png')  # TODO : fix sizing

"""## Time Chart"""

df.loc[(df['White'] == 'Torrent80') & (df['Black'] == 'Torrent80')]['Time'].sum()

matchup_times_dict = {}
for white_player in player_names:
  matchup_times_dict[white_player] = {}
  for black_player in player_names:
    # Collect all matches from database with white player and black player
    # Consolidate them into stalement and win/loss/staledraw (store as tuple first?)
    # In future, cinlude more info, like average move length
    total_time = df.loc[(df['White'] == white_player) & (df['Black'] == black_player)]['Time'].sum()

    # Append to dict
    matchup_times_dict[white_player][black_player] = total_time
    # matchups_dict[white_player][black_player] = white_wins
matchup_times_df = pd.DataFrame(matchup_times_dict)

times_sum = matchup_times_df.sum()
plt.figure(figsize=(12, 4))
plt.xlabel("Player")
plt.ylabel("Time in Seconds")
plt.bar(player_names, times_sum)
plt.xticks(rotation=90)
# plt.show()
plt.savefig('matchup_times.png')  # TODO : fix sizing

plt.pie(times_sum, labels=player_names)
plt.savefig('times_pie_chart.png')

"""## Misc Searches"""

# Selecting rows based on column values, notice use of & instead of and for boolean
df.loc[(df['White'] == 'AlwaysRandom') & (df['Black'] == 'RandShark')]

# Iterating through example
for index, row in df.loc[(df['White'] == 'AlwaysRandom') & (df['Black'] == 'RandShark')].iterrows():
  print(row['Winner'])

# Get Win proportions for a single match
df.loc[(df['White'] == 'AlwaysRandom') & (df['Black'] == 'RandShark')]['Winner'].value_counts(normalize=True)
for index, item in df.loc[(df['White'] == 'AlwaysRandom') & (df['Black'] == 'RandShark')]['Winner'].value_counts(
        normalize=True).items():
  print(index, item)
# Idea: for every both, calculate its win percent against the other bot as the color

df.loc[(df['Winner'] == 'DanceKing')]

# TODO : figure out what to do with this section. refactor?
# """# Playing with Stockfish Depths
#
# ## Testing multiple thinking times with default depth
# """
# eg_sf = Stockfish100Bot(engine, base_limit)
#
# def generate_limits(time_depth_arr):
#   lims = []
#   for time_depth in time_depth_arr:
#     time, depth = time_depth
#     lim = chess.engine.Limit
#     if depth == -1:
#       lim = chess.engine.Limit(time)
#     else:
#       lim = chess.engine.Limit(time, depth)
#     lims.append(lim)
#   return lims
#
# def generate_sf_bots(lims):
#   bots = []
#   for lim in lims:
#     sf = Stockfish100Bot(engine, lim)
#     bots.append(sf)
#   return bots

# time_depths = [
#     (0.1, 2),
#     (0.1, 4),
#     (0.1, 6),
#     (0.1, 8),
#     (0.1, 10),
#     (0.1, 15),
#     (0.1, 20),
#     (0.1, -1)
# ]
#
# lims = generate_limits(time_depths)
# sf_bots = generate_sf_bots(lims)
#
# game_results = play_tournament(sf_bots, 5, False)
#
# player_names = []
# for bot in sf_bots:
#   player_names.append(str(bot))
# print(player_names)
